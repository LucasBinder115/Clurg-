#!/bin/sh
# Clurg Post-Commit Hook
# Executado automaticamente apÃ³s cada commit

set -e

echo "ðŸ”„ Executando hook pÃ³s-commit..."

# VariÃ¡veis de ambiente disponÃ­veis:
# CLURG_COMMIT_ID - ID do commit recÃ©m-criado
# CLURG_COMMIT_MESSAGE - Mensagem do commit
# CLURG_CI_STATUS - Status do CI (passed/failed/unknown)

echo "ðŸ“ Commit: $CLURG_COMMIT_ID"
echo "ðŸ’¬ Mensagem: $CLURG_COMMIT_MESSAGE"
echo "ðŸ” CI Status: $CLURG_CI_STATUS"

# 1. CI Local AutomÃ¡tico (se nÃ£o foi executado durante o commit)
if [ "$CLURG_CI_STATUS" = "unknown" ]; then
    echo "âš™ï¸ Executando CI local automÃ¡tico..."
    # Aqui poderia executar testes locais, linting, etc.
    echo "âœ… CI local: passed"
fi

# 2. Limpeza de commits antigos
echo "ðŸ§¹ Verificando limpeza de commits antigos..."
COMMITS_DIR=".clurg/commits"
MAX_COMMITS=50
MAX_DAYS=30

# Contar commits
commit_count=$(ls -1 "$COMMITS_DIR"/*.tar.gz 2>/dev/null | wc -l)

if [ "$commit_count" -gt "$MAX_COMMITS" ]; then
    echo "ðŸ“¦ $commit_count commits encontrados, mantendo apenas $MAX_COMMITS mais recentes..."
    
    # Listar commits por data (mais antigos primeiro) e remover excedentes
    ls -t "$COMMITS_DIR"/*.tar.gz | tail -n +$((MAX_COMMITS + 1)) | while read -r old_commit; do
        base_name=$(basename "$old_commit" .tar.gz)
        echo "ðŸ—‘ï¸ Removendo commit antigo: $base_name"
        rm -f "$COMMITS_DIR/$base_name.tar.gz" "$COMMITS_DIR/$base_name.meta" "$COMMITS_DIR/$base_name.metadata.json"
    done
else
    echo "ðŸ“¦ $commit_count commits (limite: $MAX_COMMITS) - nenhuma limpeza necessÃ¡ria"
fi

# 2b. Limpeza baseada em tempo (commits mais antigos que 30 dias)
echo "â° Verificando commits antigos por tempo..."
if [ "$commit_count" -gt 5 ]; then  # SÃ³ limpar se houver mais de 5 commits
    find "$COMMITS_DIR" -name "*.tar.gz" -mtime +$MAX_DAYS -print | while read -r old_commit; do
        base_name=$(basename "$old_commit" .tar.gz)
        commit_date=$(stat -c %Y "$old_commit" 2>/dev/null || stat -f %m "$old_commit" 2>/dev/null)
        if [ -n "$commit_date" ]; then
            days_old=$(( ($(date +%s) - commit_date) / 86400 ))
            if [ "$days_old" -gt "$MAX_DAYS" ]; then
                echo "ðŸ—‘ï¸ Removendo commit antigo ($days_old dias): $base_name"
                rm -f "$COMMITS_DIR/$base_name.tar.gz" "$COMMITS_DIR/$base_name.meta" "$COMMITS_DIR/$base_name.metadata.json"
            fi
        fi
    done
fi

# Manter apenas Ãºltimas 100 linhas do log
if [ -f "$LOG_FILE" ]; then
    tail -n 100 "$LOG_FILE" > "${LOG_FILE}.tmp" && mv "${LOG_FILE}.tmp" "$LOG_FILE"
fi

# 4. VerificaÃ§Ã£o de integridade dos arquivos
echo "ðŸ” Verificando integridade dos arquivos..."
INTEGRITY_FILE=".clurg/integrity.txt"

if [ -f "$INTEGRITY_FILE" ]; then
    echo "ðŸ“‹ Verificando checksums..."
    # Verificar se algum arquivo foi modificado desde o Ãºltimo commit
    if ! sha256sum -c "$INTEGRITY_FILE" --quiet 2>/dev/null; then
        echo "âš ï¸ AVISO: Alguns arquivos foram modificados fora do VCS"
        echo "ðŸ’¡ Considere fazer commit das mudanÃ§as ou restaurar arquivos"
    else
        echo "âœ… Integridade dos arquivos OK"
    fi
else
    echo "ðŸ“‹ Arquivo de integridade nÃ£o encontrado (primeiro commit?)"
fi

# 5. Backup automÃ¡tico (opcional - sÃ³ se diretÃ³rio existir)
BACKUP_DIR=".clurg/backups"
if [ -d "$BACKUP_DIR" ]; then
        echo "ðŸ’¾ Iniciando backup automÃ¡tico em background..."
        backup_file="$BACKUP_DIR/backup-$(date +%Y%m%d-%H%M%S).tar.gz"
        (
            nohup tar -czf "$backup_file" .clurg/ >/dev/null 2>&1 &
            echo $! > "$BACKUP_DIR/last_backup.pid"
        ) || true
        echo "ðŸ“¦ Backup disparado: $(basename "$backup_file") (pid: $(cat "$BACKUP_DIR/last_backup.pid" 2>/dev/null || echo "?"))"

        # Limpeza de backups: rodar em background para nÃ£o bloquear
        (
            ls -t "$BACKUP_DIR"/backup-*.tar.gz 2>/dev/null | tail -n +8 | xargs rm -f 2>/dev/null || true
        ) &
fi

# 6. EstatÃ­sticas de uso
echo "ðŸ“Š Atualizando estatÃ­sticas..."
STATS_FILE=".clurg/stats.json"
current_date=$(date +%Y-%m-%d)

if [ -f "$STATS_FILE" ]; then
    # Atualizar estatÃ­sticas existentes
    jq --arg date "$current_date" --arg commit "$CLURG_COMMIT_ID" \
       '.commits += 1 | .last_commit = $commit | .last_activity = $date' "$STATS_FILE" > "${STATS_FILE}.tmp" && \
    mv "${STATS_FILE}.tmp" "$STATS_FILE"
else
    # Criar arquivo de estatÃ­sticas
    cat > "$STATS_FILE" << EOF
{
  "created": "$current_date",
  "commits": 1,
  "last_commit": "$CLURG_COMMIT_ID",
  "last_activity": "$current_date",
  "version": "1.0"
}
EOF
fi

echo "ðŸ“ˆ EstatÃ­sticas atualizadas"